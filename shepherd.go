package main

import (
	"fmt"
	"time"
)


/////////////////////////////////////////////////////////////////////
type node struct {
	ip string
}

type log struct {
	id string
	metrics []string
	max_size int
	mem [][]uint64
}
type control struct {
	id string
}

// any muster is able to:
//	1. log metrics of all its sheep - i.e. cores
//	2. apply control decision changes
type Muster interface {
	heartbeat()
	log()
	control()
}

type muster struct {
	node
	id string
	hb_chan chan string

	full_buff chan string
	flush_buff chan string
	ready_buff chan string
	kill_log chan string
	process_log chan string
	ready_log chan string
	compute_ctrl chan string
	ready_ctrl chan string

	buffer *log
}

func (m muster) heartbeat() {
	for {
		select {
		case m.hb_chan <- "hb":
			time.Sleep(time.Second/10)
		default:
		}
	}
}

// this goroutine simulates logging on a remote node that in turn
// populates memory on this shepherd node
func (m muster) simulate_remote_log(c int, v uint64) {
	fmt.Println(m.id + " -- -- -- -- SIMULATING REMOTE LOG -- counter = ", c, " , val = ", v)
	counter := c
	val := v
	for {
		select {
		case <- m.kill_log:
			m.buffer.mem = make([][]uint64, 0)
			go m.simulate_remote_log(c, v)
			return
		default:
			if counter == m.buffer.max_size { 
				m.full_buff <- "FULL"
				<- m.ready_buff
				m.buffer.mem = make([][]uint64, 0)
				counter = 0
			}
			m.buffer.mem = append(m.buffer.mem, []uint64{val, val * 2})
			val += 1
			counter += 1
			time.Sleep(time.Second/100)
		}
	}
}

/* a muster will start and continue to log metrics until interrupted to do otherwise */
func (m muster) log() {
	// start logging if muster is up
	<- m.hb_chan
	fmt.Println("---> LOG: ", m.id, " starting logging..")

	/* - note that this is a muster thread started by the shepherd on this machine 
	   - it is not a muster thread running on a remote machine 
	   - this muster thread will have to be implemented to communicate with the actual
	     muster that is logging on some remote node */

	go m.simulate_remote_log(0, 0)

	// shepherd-muster local thread waits to handle full remote logs
	for {
		select {
		case <- m.flush_buff:
			fmt.Println(m.id + " FLUSH BUFF NEEDED AFTER CONTROL CHANGE ")
			m.kill_log <- ""
		case <- m.full_buff:
			fmt.Println(m.id + " FLUSH BUFF NEEDED ")
			m.process_log <- ""
			<- m.ready_log
			m.ready_buff <- "READY"
		}
	}
}

func (m muster) control() {
	// start control if muster is up
	<- m.hb_chan
	fmt.Println("---> CONTROL: ", m.id, " starting control..")

	for {
		select {
		case <- m.ready_ctrl:
			fmt.Println(m.id + " NEW CONTROL DECISION MADE ")
			m.flush_buff <- ""
			//<- m.ready_buff
			//<- m.ready_log
			//m.ready_buff <- "READY"
		}
	}
}


///////////////////////////////////////////////////////////////


// any shepherd is able to:
//	1. deploy N musters to N pastures - i.e. nodes
//	2. process logs generated by the N deployed musters
//	3. compute a control decision given information in the logs
type Shepherd interface {
	deploy_musters()
	process_logs()
	compute_control()
}
// any shepherd has a shepherd id s_id and a list of musters
// that it is responsible for
type shepherd struct {
	id int
	m_map map[string]muster
}

func (s *shepherd) init(n_list []node) {
	s.id = 1101
	s.m_map = make(map[string]muster)
	for i := 0; i < len(n_list); i ++ {
		m_id := n_list[i].ip + "-id"
		m_hb_chan := make(chan string)
		m_full_buff := make(chan string, 1)
		m_flush_buff := make(chan string, 1)
		m_ready_buff := make(chan string, 1)
		m_kill_log := make(chan string, 1)
		m_process_log := make(chan string, 1)
		m_ready_log := make(chan string, 1)
		m_compute_ctrl := make(chan string, 1)
		m_ready_ctrl := make(chan string, 1)
		m_buffer := &log{id: m_id + "-log"}
		s.m_map[m_id] = muster{node: n_list[i], id: m_id, hb_chan: m_hb_chan, 
							full_buff: m_full_buff, flush_buff: m_flush_buff, ready_buff: m_ready_buff, 
							kill_log: m_kill_log, process_log: m_process_log, ready_log: m_ready_log, 
							compute_ctrl: m_compute_ctrl, ready_ctrl: m_ready_ctrl, buffer: m_buffer}
	}
}

func (s *shepherd) listen_heartbeats() {
	fmt.Println("--> LISTEN_HEARTBEATS: now the shepherd can receive heartbeats from musters")
	for {
		for m_id, _ := range(s.m_map) {
			select {
			case <- s.m_map[m_id].hb_chan:
				fmt.Println("-- -- heartbeat from ", m_id)
			}
		}
	}
}

func (s *shepherd) wait_and_process(m_id string) {
	for {
		select {
		case <- s.m_map[m_id].process_log:
			fmt.Println(m_id + " PROCESSING LOGS")
			// do processing
			s.m_map[m_id].ready_log <- ""
			s.m_map[m_id].compute_ctrl <- ""
		}
	}
}

func (s *shepherd) wait_and_control(m_id string) {
	for {
		select {
		case <- s.m_map[m_id].compute_ctrl:
			fmt.Println(m_id + " COMPUTING CONTROL")
			// do computation
			s.m_map[m_id].ready_ctrl <- ""
		}
	}
}


///////////////////////////////////////////////////////////////////////


/* A shepherd is defined to watch for some property of execution, 
   (e.g. energy proportionality (EP)) and optimize for it. 
   An optimization methodology is defined by the type of data
   it acquires (e.g. timestamp and joules counter logs) and the 
   computation it performs on this data (e.g. bayesian optimization)
   in order to output a optimal control decision (e.g. ITR-delay and 
   DVFS settings).

   So, a shepherd is defined by its target and optimization methodology.
*/
// e.g. a shepherd that targets energy proportionality using bayesian optimization
type ep_bayopt_shepherd struct {
	shepherd
}

func (s ep_bayopt_shepherd) deploy_musters() {
	fmt.Println("-> DEPLOY_MUSTERS: this function implements a shepherd's initialization of its musters.")
	for m_id, _ := range(s.m_map) {
		m_id := m_id
		fmt.Println("--> starting muster ", s.m_map[m_id])
		/* specialize muster to log ep_bayopt metrics and control for ep_bayopt settings */
		s.m_map[m_id].buffer.metrics = append(s.m_map[m_id].buffer.metrics, "timestamp", "joules")
		s.m_map[m_id].buffer.max_size = 64
		mem := make([][]uint64, 0)
		s.m_map[m_id].buffer.mem = mem

		go func() {
			go s.m_map[m_id].heartbeat()
			go s.m_map[m_id].log()
			go s.m_map[m_id].control()
		} ()
	}
	go s.listen_heartbeats()
}

func (s ep_bayopt_shepherd) process_logs() {
	fmt.Println("-> PROCESS_LOGS: this function implements a shepherd's processing of logs from its musters.")
	for m_id, _ := range(s.m_map) {
		go s.wait_and_process(m_id)
	}
}

func (s ep_bayopt_shepherd) compute_control() {
	fmt.Println("-> COMPUTE_CONTROL: this function implements a shepherd's computation of a control decision.")
	for m_id, _ := range(s.m_map) {
		go s.wait_and_control(m_id)
	}
}

func main() {
	n_list := []node{node{ip: "10.0.1.1"}, node{ip: "10.0.1.2"}, node{ip: "10.0.1.3"}, node{ip: "10.0.1.4"}}
	s1 := ep_bayopt_shepherd{}
	fmt.Println("MAIN: declared shepherd s1.id = ", s1.id, ", s1.m_map = ", s1.m_map)
	s1.init(n_list)
	fmt.Println("MAIN: initialized shepherd ", s1)
	s1.deploy_musters()
	fmt.Println("MAIN: ep_bayeopt_shepherd ready: ", s1)
	fmt.Println("MAIN: ep_bayeopt_shepherd musters ready: ")
	for m_id, m := range(s1.m_map) {
		fmt.Println(m_id, m, m.buffer, m.buffer.mem)
	}
	s1.process_logs()
	s1.compute_control()
	time.Sleep(time.Second*2)
	fmt.Println("MAIN: ep_bayeopt_shepherd musters: ")
	for m_id, m := range(s1.m_map) {
		fmt.Println(m_id, m, m.buffer, m.buffer.mem)
	}
}






