package main

import (
	"fmt"
	"time"
)


/////////////////////////////////////////////////////////////////////


type node struct {
	ip string
}

// any muster is able to:
//	1. log metrics of all its sheep - i.e. cores
//	2. apply control decision changes
type Muster interface {
	heartbeat()
	log()
	control()
}
type muster struct {
	node
	id string
	hb_chan chan string
}

func (m muster) heartbeat() {
	for {
		select {
		case m.hb_chan <- "hb":
			time.Sleep(time.Second/10)
		default:
		}
	}
}

func (m muster) log() {
	// start logging if muster is up
	<- m.hb_chan
	fmt.Println("---> LOG: ", m.id, " starting logging..")
}


///////////////////////////////////////////////////////////////


// any shepherd is able to:
//	1. deploy N musters to N pastures - i.e. nodes
//	2. process logs generated by the N deployed musters
//	3. compute a control decision given information in the logs
type Shepherd interface {
	deploy_musters()
	process_logs()
	compute_control()
}
// any shepherd has a shepherd id s_id and a list of musters
// that it is responsible for
type shepherd struct {
	id int
	m_map map[string]muster
}

func (s *shepherd) init(n_list []node) {
	s.id = 1101
	s.m_map = make(map[string]muster)
	for i := 0; i < len(n_list); i ++ {
		m_id := n_list[i].ip + "-id"
		m_hb_chan := make(chan string)
		s.m_map[m_id] = muster{n_list[i], m_id, m_hb_chan}
	}
}

func (s *shepherd) run_muster(m_id string) {
	fmt.Println("--> RUN_MUSTER: starting muster ", s.m_map[m_id])
	go s.m_map[m_id].heartbeat()
	go s.m_map[m_id].log()
	//go s.m_map[m_id].control()
}

func (s *shepherd) listen_heartbeats() {
	fmt.Println("--> LISTEN_HEARTBEATS: now the shepherd can receive heartbeats from musters")
	for {
		for m_id, _ := range(s.m_map) {
			select {
			case <- s.m_map[m_id].hb_chan:
				fmt.Println("-- -- heartbeat from ", m_id)
			}
		}
	}
}

///////////////////////////////////////////////////////////////////////


/* A shepherd is defined to watch for some property of execution, 
   (e.g. energy proportionality (EP)) and optimize for it. 
   An optimization methodology is defined by the type of data
   it acquires (e.g. timestamp and joules counter logs) and the 
   computation it performs on this data (e.g. bayesian optimization)
   in order to output a optimal control decision (e.g. ITR-delay and 
   DVFS settings).

   So, a shepherd is defined by its target and optimization methodology.
*/
// e.g. a shepherd that targets energy proportionality using bayesian optimization
type ep_bayopt_shepherd struct {
	shepherd
}
func (s ep_bayopt_shepherd) deploy_musters() {
	fmt.Println("-> DEPLOY_MUSTERS: this function implements a shepherd's initialization of its musters.")
	for m_id, _ := range(s.m_map) {
		m_id := m_id
		go s.run_muster(m_id)
	}
	go s.listen_heartbeats()
}
func (s ep_bayopt_shepherd) process_logs() {
	fmt.Println("-> PROCESS_LOGS: this function implements a shepherd's processing of logs from its musters.")
}
func (s ep_bayopt_shepherd) compute_control() {
	fmt.Println("-> COMPUTE_CONTROL: this function implements a shepherd's computation of a control decision.")
}

func main() {
	n_list := []node{node{ip: "10.0.1.1"}, node{ip: "10.0.1.2"}, node{ip: "10.0.1.3"}, node{ip: "10.0.1.4"}}
	s1 := ep_bayopt_shepherd{}
	fmt.Println("MAIN: declared shepherd s1.id = ", s1.id, ", s1.m_map = ", s1.m_map)
	s1.init(n_list)
	fmt.Println("MAIN: initialized shepherd ", s1)
	s1.deploy_musters()
	s1.process_logs()
	s1.compute_control()
	time.Sleep(time.Second)
}






